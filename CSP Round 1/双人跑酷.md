题目很好理解。

`10%` 

随便搜不WA必过此数据范围，甚至可以骗分。

`40%`

先预处理，如果某点可以使用滑行合法，必有且只有一个对应终点。

数据范围$H <= 10$模拟即可，预处理复杂度最大$O(NH)$并且必跑不满。

然后跑DFS，每层可以执行四种操作（两人步行，其中一人滑行，两人都滑行），直到两人都到达或超过终点判断金币是否全部捡起。

看起来最大复杂度$O(4^N)$，然而必跑不满，滑行会导致有些N被跳过，不滑行就变成$O(N)$。

好像复杂度还是很大，加上玄学最优化剪枝，并不好出毒瘤数据来卡，实测能过此数据范围。

`60%`

DFS写的好，或者DP写丑了。

`100%`

一样的预处理，但这次我们用vector数组$v[N]$存储，$v_i$表示哪些点可以滑行到i点。

设一个动态规划数组$F[N][N]$，第一维表示两人捡完前i格所有金币，第二维表示某个人跑了j步，值等于另一个人跑了多少步。

将数组为无穷大，$F[0][0]= 0$。从1到N枚举每格，第i格从i-1格转移，再枚举每步。

$F[i][j] = F[i - 1][j - 1] + 1$

如果此格是一个合法的滑行终点就继续讨论，由于数组是对称取min的，因此写出。

$f[i][j]= min(f[i][j], f[l][j - 1] + i - l)$
$f[i][j]= min(f[i][j], f[l][j - i + l] + 1)$

l代表从某点可滑行到此点。正确性在于某人滑行，某人就必须捡起滑行路上所有的金币。

复杂度$O(N^2)$是正确的，因为滑行最多也只能执行N次加起来也是$O(N^2)$。

似乎发现不需要开vector，好像可以和DFS一个套路，直接更新后面的点。

`扩展`

似乎有非常快的做法，我并没有看懂代码，所以邀请这位大佬来讲一下。


